#define WIN32_LEAN_AND_MEAN
#include "config.h"
#ifdef HAVE_ALAZAR
#include <Windows.h>
#include <stdlib.h>
#include <stdio.h> //for logging
#include <AlazarApi.h>
#include <AlazarCmd.h>
#include "alazar.h"

/** \file

    \todo Only modify input levels for enabled channels.
    \todo Test triggering.
    \todo Organize static interface and document a little.
    \todo ?Add a method for configuring sample rate.

    \section Macros

    \def LOG(...)          Used like a printf() call.  All logging-related messages should for this module should go through LOG()
    \def ENDL              The end-of-line character(s) to use.
    \def TRY(e)            Jumps to a label named "Error," if the expression \a e evaluates to falss and reports the event.
    \def ERR(e)            Similar to try, but checks for error codes generated by API calls.  \a e should evaluate to an ATS SDK error code.
    \def NEW(e,type,count) Shorthand expression that allocates an array of \a count objects sized by \type.  Checks to make sure the pointer is not NULL and zeros the array.
*/

#if 1 // PROFILING
#define TS_OPEN(name)   timestream_t ts__=timestream_open(name)
#define TS_TIC          timestream_tic(ts__)
#define TS_TOC          timestream_toc(ts__)
#define TS_CLOSE        timestream_close(ts__)
#else
#define TS_OPEN(name)
#define TS_TIC
#define TS_TOC
#define TS_CLOSE
#endif

#define DEBUG 1
#if DEBUG==0
    #define DBG(...)
    #define DBG_VERBOSE(...)
#elif DEBUG==1
    #define DBG(...) LOG(__VA_ARGS__)
    #define DBG_VERBOSE(...)
#else
    #define DBG(...) LOG(__VA_ARGS__)
    #define DBG_VERBOSE(...) LOG(__VA_ARGS__)
#endif

#define LOG(...)          printf(__VA_ARGS__)
#define ENDL              "\n"
static void breakme() {LOG(" ");}
#define REPORT(type,e,msg)     LOG("%s(%d) - %s(): %s"ENDL "\t%s"ENDL "\tExpression evaluated as false."ENDL "\t%s"ENDL,__FILE__,__LINE__,__FUNCTION__,type,e,msg)
#define REPORT_ATS(code,e)     LOG("%s(%d) - %s(): ATS API"ENDL "\t%s"ENDL "\tAlazar API call failed (error code %d)."ENDL "\t%s"ENDL ,__FILE__,__LINE__,__FUNCTION__,e,code,AlazarErrorToText(code))
#define TRY(e)            do{if(!(e)){REPORT("Error"  ,#e,"" ); breakme(); goto Error;}}while(0)
#define WARN(e,msg)       do{if(!(e)){REPORT("Warning",#e,msg);                       }}while(0)
#define FAIL(msg)         do{if(!(e)){REPORT("Error"  ,"Forced failure.",msg);            goto Error;}}while(0)
#define ERR(e)            do{RETURN_CODE code=(e); if(code!=ApiSuccess) {REPORT_ATS(code,#e); breakme(); goto Error;}}while(0)
#define ATSWARN(e)        do{RETURN_CODE code=(e); if(code!=ApiSuccess) {REPORT_ATS(code,#e); breakme();            }}while(0)
#define NEW(e,type,count)  TRY((e)=(type*)calloc(count,sizeof(type)))
#define ZERO(e,type,count) memset((e),0,count*sizeof(type))
#define SAFEFREE(e)       do{if(e) {free(e); (e)=NULL;}}while(0)

#define VALIDATE(e)       do{if(!(e) || !((e)->cfg)) { LOG("%s(%d): %s"ENDL "\tContext is invalid.  There was a past error."ENDL,__FILE__,__LINE__,__FUNCTION__); breakme(); goto Error;} }while(0)

#define SUCCESS (1)
#define FAILURE (0)

#define BOARD(i) (ctx->boards[i])
#define BOARDS   (ctx[0]->boards)

#define BUFS_PER_BOARD (2)
#define MAXBOARDS      (4)
#define CHANSPERBOARD  (2)

/** Configuration parameters.

 Reference counted.  The device will hold a reference to a configuration
 object until it is disarmed.
 */
struct _alazar_cfg_t
{
  U32 ref;                                                                 ///< reference counter
  U32 nsamples;                                                            ///< samples per record
  U32 nrecords;                                                            ///< number of records
  U32 sample_rate_id;                                                      ///< ATS-SDK constant specifying sample rate
  double line_trig_lvl_volts;                                              ///< 0-255.  Full range given by input_range_id.
  U32 aux_out_board_id;                                                    ///< a board id, 0-3 depending on how many boards are in the system.
  U32 enable[MAXBOARDS][CHANSPERBOARD];                                    ///< bool indicating whether to enable a channel
  U32 input_range_ids[MAXBOARDS][CHANSPERBOARD];                           ///< ATS-SDK constant specifying input range
};
/** Device context for the board system. */
struct _alazar_t
{ U32          system_id;                                                  ///< valid system id's are 1..systemCount (inclusive)
  U32          nboards;                                                    ///< valid board id's are 1..board_count (inclusive)
  HANDLE       boards[MAXBOARDS];                                          ///< handles used to adress the boards in the system
  void        *bufs[MAXBOARDS][BUFS_PER_BOARD];                            ///< array of page-locked buffers for async DMA transfers
  RETURN_CODE  last;                                                       ///< error code from last ATS SDK call.
  alazar_cfg_t cfg;                                                        ///< parameters used to configure the device.
  U32          is_started;                                                 ///< Indicates acquisition has been started.
  U32          ibuf;                                                       ///< Index to the current read point of bufs.
  SRWLOCK      lock;                                                       ///< Mutex to protect access
  char         lock_mode;
};

//  EXTRAS                     ////////////////////////////////////////////

/* public */
int alazar_print_version(FILE* fp)
{
  U8 major,minor,rev;
  ERR(AlazarGetSDKVersion(&major,&minor,&rev));
  fprintf(fp,"Alazar SDK Version %u.%u.%u\n",major,minor,rev);
  ERR(AlazarGetDriverVersion(&major,&minor,&rev));
  fprintf(fp,"Alazar Driver Version %u.%u.%u\n",major,minor,rev);

  { int i,n=0;
    TRY(AlazarNumOfSystems()==1);             //ensure single system
    TRY(n=AlazarBoardsInSystemBySystemID(1)); //ensure >0
    fprintf(fp,"Alazar Firmware(CPLD) Version:\n");
    for(i=0;i<n;++i)
    { HANDLE board=AlazarGetBoardBySystemID(1,i+1);
      ERR(AlazarGetCPLDVersion(board,&major,&minor));
      fprintf(fp,"\tBoard %2d - Version %u.%u (HANDLE: 0x%p)\n",i,major,minor,board);
    }
  }
  return 1;
Error:
  fprintf(fp,"Error querying Alazar ATS SDK version numbers.\n");
  return 0;
}

//  STATIC INTERFACE - Queries ////////////////////////////////////////////

/** \returns the number of enabled channels across all boards */
static size_t active_channel_count(alazar_t ctx)
{
  unsigned i,j,c=0;
  VALIDATE(ctx);
  if(!ctx->cfg) return 0;
  for(i=0;i<ctx->nboards;++i)  // two channels per board
    for(j=0;j<2;++j)
      c+=ctx->cfg->enable[i][j];
  return c;
Error:
  return 1; // avoid divide by zero
}

/** \returns the size in bytes required to acquire all channels */
static size_t buffer_size_bytes(alazar_t ctx)
{ size_t out;
  VALIDATE(ctx);
  out=active_channel_count(ctx)*ctx->cfg->nrecords*ctx->cfg->nsamples*2;
  DBG_VERBOSE("Buffer Size Bytes: %d"ENDL
      "\tActive Channel Count: %d"ENDL
      "\tRecords             : %d"ENDL
      "\tSamples             : %d"ENDL
      "\tBpp                 : %d"ENDL,
      (int)out,
      (int)active_channel_count(ctx),
      (int)ctx->cfg->nrecords,
      (int)ctx->cfg->nsamples,
      (int)2);
  return out; /*2 Bpp*/
Error:
  return 0;
}

/** \returns true if the device is armed, otherwise false */
static int alazar_is_armed(alazar_t ctx)
{
  return ctx->cfg!=0;
}

/** \returns true if acquisition has been started, otherwise false */
static int alazar_is_started(alazar_t ctx)
{  return ctx->is_started;
}

/** \returns the channel mask specifying enabled channels on board \a i */
static U32 channel_mask(alazar_t ctx, int i)
{
  return (ctx->cfg->enable[i][0]?CHANNEL_A:0)
       | (ctx->cfg->enable[i][1]?CHANNEL_B:0);
}

/** Translates a rate id defined by the ATS-SDK into a real number.
    \returns the sample rate in Hz.
*/
static double samples_per_second(U32 rate_id)
{
  switch(rate_id)
  {
  case SAMPLE_RATE_1KSPS		: return   1e3;
  case SAMPLE_RATE_2KSPS		: return   2e3;
  case SAMPLE_RATE_5KSPS		: return   5e3;
  case SAMPLE_RATE_10KSPS		: return  10e3;
  case SAMPLE_RATE_20KSPS		: return  20e3;
  case SAMPLE_RATE_50KSPS		: return  50e3;
  case SAMPLE_RATE_100KSPS	: return 100e3;
  case SAMPLE_RATE_200KSPS	: return 200e3;
  case SAMPLE_RATE_500KSPS	: return 500e3;
  case SAMPLE_RATE_1MSPS		: return   1e6;
  case SAMPLE_RATE_2MSPS		: return   2e6;
  case SAMPLE_RATE_5MSPS		: return   5e6;
  case SAMPLE_RATE_10MSPS		: return  10e6;
  case SAMPLE_RATE_20MSPS		: return  20e6;
  case SAMPLE_RATE_25MSPS		: return  25e6;
  case SAMPLE_RATE_50MSPS		: return  50e6;
  case SAMPLE_RATE_100MSPS	: return 100e6;
  case SAMPLE_RATE_125MSPS	: return 125e6;
  case SAMPLE_RATE_160MSPS	: return 160e6;
  case SAMPLE_RATE_180MSPS	: return 180e6;
  case SAMPLE_RATE_200MSPS	: return 200e6;
  case SAMPLE_RATE_250MSPS  : return 250e6;
  case SAMPLE_RATE_500MSPS  : return 500e6;
  case SAMPLE_RATE_1GSPS    : return   1e9;
  case SAMPLE_RATE_2GSPS    : return   2e9;
  default:
    /// \todo better exception handling here?
    WARN(0,"Unrecognized sample rate id.");
    return 0.0;
  }
}

/** Queries the operating system for the page size */
static unsigned page_alignment_samples()
{
  unsigned bytes;
#ifdef _MSC_VER
  {
    SYSTEM_INFO info={0};
    GetSystemInfo(&info);
    bytes=info.dwPageSize;
  }
#else
  FAIL("Not implemented.");
Error:
  abort();
  return 0;
#endif
  return bytes/2; /*2 bytes per sample*/
}

//  STATIC INTERFACE - Memory management //////////////////////////////////

/** Allocates page aligned memory */
static void* page_alloc(size_t bytes)
{ void *out;
  TRY(bytes>0);
#ifdef _MSC_VER
    TRY(out=VirtualAlloc(NULL,bytes,MEM_COMMIT,PAGE_READWRITE));
#else
    FAIL("Allocation of page locked memory with valloc() not implemented (yet).");
#endif
  return out;
Error:
  return NULL;
}

/** Frees page aligned memory */
static void page_dealloc(void **buf)
{
  if(!buf || !*buf) return;
#ifdef _MSC_VER
  VirtualFree(*buf,0,MEM_RELEASE);
  *buf=NULL;
#else
  FAIL("DeAllocation of page locked memory not implemented (yet).");
Error:
  abort()
#endif;
}

static void free_alazar_t(alazar_t *ctx)
{ if(ctx && *ctx)
  { free(ctx[0]);
    ctx[0]=0;
  }
}

/** allocates async DMA bufs for each board */
static int alloc_bufs(alazar_t ctx)
{ unsigned i,j;
  VALIDATE(ctx);
  { const size_t bytes = 2*buffer_size_bytes(ctx)/active_channel_count(ctx); // two channels per board
    TRY(bytes>0);
    TRY(ctx && ctx->nboards>0);
    for(j=0;j<ctx->nboards;++j)
      for(i=0;i<BUFS_PER_BOARD;++i)
        TRY(ctx->bufs[j][i]=page_alloc(bytes));
  }
  return SUCCESS;
Error:
  return FAILURE;
}

/* public */
void alazar_free_buf(void **buf)
{ free(*buf);
  *buf=0;
}

static void free_bufs(alazar_t ctx)
{ unsigned i,j;
  if(!ctx) return;
  if(!ctx->bufs) return;
  for(j=0;j<ctx->nboards;++j)
    for(i=0;i<BUFS_PER_BOARD;++i)
      page_dealloc(ctx->bufs[j]+i);
}

static U32 line_trigger_level(alazar_t ctx)
{ VALIDATE(ctx);
  return (U32) (128.0*(1.0+ctx->cfg->line_trig_lvl_volts/5.0)); // assumes 5.0V range on external trigger
Error:
  return 0; // this is a valid trigger level...can't test for error with this value
}

static void lock(alazar_t ctx, char mode)
{ switch(mode)
  { case 'r': AcquireSRWLockShared(&ctx->lock); break;
    case 'w': AcquireSRWLockExclusive(&ctx->lock); break;
    default: abort();
  }
  //LOG("+++ ALAZAR LOCK ACQUIRED MODE %c\n",mode);
  ctx->lock_mode=mode;
}
static void unlock(alazar_t ctx)
{ char mode=ctx->lock_mode;
  ctx->lock_mode=0;
  //LOG("--- ALAZAR LOCK RELEASED MODE %c\n",mode);
  switch(mode)
  { case 'r': ReleaseSRWLockShared(&ctx->lock); break;
    case 'w': ReleaseSRWLockExclusive(&ctx->lock); break;
    default: abort();
  }
}


//  DEVICE INTERFACE /////////////////////////////////////////////////////

int alazar_alloc_buf(alazar_t ctx, void **buf)
{ lock(ctx,'r');
  TRY(alazar_is_armed(ctx));
  TRY(buf);
  TRY(*buf=malloc(buffer_size_bytes(ctx)));
  unlock(ctx);
  return SUCCESS;
Error:
  unlock(ctx);
  return FAILURE;
}

/** Acquires the device context for the board system.

  Current policies:
  1. Use first discovered system.
  2. Use all the boards in that system.
  */
int alazar_attach(alazar_t *ctx)
{
  U32 n,i;
  TRY(AlazarNumOfSystems()==1);                             //ensure single system
  NEW( ctx[0],struct _alazar_t,1);
  ZERO(ctx[0],struct _alazar_t,1);
  ctx[0]->last=ApiSuccess;
  ctx[0]->system_id = 1;
  TRY(ctx[0]->nboards=n=AlazarBoardsInSystemBySystemID(1)); //ensure >0
  for(i=0;i<n;++i)
    BOARDS[i]=AlazarGetBoardBySystemID(1,i+1);
  //ctx->lock=SRWLOCK_INIT;
  return SUCCESS;
Error:
  free_alazar_t(ctx);
  return FAILURE;
}

/** Releases the device context */
int alazar_detach(alazar_t *ctx)
{ if(!ctx || !*ctx) return SUCCESS;
  if(alazar_is_armed(*ctx))
    WARN(alazar_disarm(*ctx),"Trying to disarm.");
  free_alazar_t(ctx);
  return SUCCESS;
}

/** Validates and applies configuration settings to the device. */
int alazar_arm(alazar_t ctx, alazar_cfg_t cfg)
{ unsigned i,j;
  lock(ctx,'w');
  if(alazar_is_armed(ctx))
  { WARN(!alazar_is_armed(ctx),"Must disarm before re-arming.");
    goto Error;
  }
  ctx->cfg=cfg;
  cfg->ref++;
  ///// CHANNELS AND TRIGGERS
  for(i=0;i<ctx->nboards;++i)
  { ERR(AlazarSetCaptureClock(BOARD(i),INTERNAL_CLOCK,cfg->sample_rate_id,CLOCK_EDGE_RISING,0/*decimation*/));
    ERR(AlazarInputControl(BOARD(i),CHANNEL_A,DC_COUPLING,cfg->input_range_ids[i][0],IMPEDANCE_50_OHM));
    ERR(AlazarSetBWLimit(BOARD(i),CHANNEL_A,0/*disable*/));
    ERR(AlazarInputControl(BOARD(i),CHANNEL_B,DC_COUPLING,cfg->input_range_ids[i][1],IMPEDANCE_50_OHM));
    ERR(AlazarSetBWLimit(BOARD(i),CHANNEL_B,0/*disable*/));
  }
  // assume BOARD(0) is the master
  ERR(AlazarSetTriggerOperation(BOARD(0),TRIG_ENGINE_OP_J,                               // external trigger accepts line trigger
           TRIG_ENGINE_J,TRIG_EXTERNAL,TRIGGER_SLOPE_POSITIVE,line_trigger_level(ctx),
           TRIG_ENGINE_K,TRIG_DISABLE,TRIGGER_SLOPE_POSITIVE,0));
  ERR(AlazarSetExternalTrigger(BOARD(0),DC_COUPLING,ETR_5V));                            // set voltage range for line trigger (must be 5V for 9350)
  ERR(AlazarSetTriggerDelay(BOARD(0),0));
  ERR(AlazarSetTriggerTimeOut(BOARD(0),0));                                              // Disable timeout
  ERR(AlazarConfigureAuxIO(BOARD(0),AUX_IN_TRIGGER_ENABLE,TRIGGER_SLOPE_POSITIVE));      // config "digitizer ready" output

  //ERR(AlazarConfigureAuxIO(BOARD(1),AUX_OUT_TRIGGER,0));
  ERR(AlazarConfigureAuxIO(BOARD(cfg->aux_out_board_id),AUX_OUT_BUSY,0));

///// ALLOCATE WORKING MEMORY
  TRY(alloc_bufs(ctx));
  unlock(ctx);
  return SUCCESS;
Error:
  if(ctx && ctx->nboards)
  { unsigned i;
    for(i=0;i<ctx->nboards;++i)
      if(BOARD(i))
        ATSWARN(AlazarAbortAsyncRead(BOARD(i)));
  }
  ctx->cfg=NULL;
  cfg->ref--;
  unlock(ctx);
  return FAILURE;
}

/** Releases configuration-specific resources. */
int alazar_disarm(alazar_t ctx)
{ unsigned i;
  if(!ctx) return SUCCESS;
  if(alazar_is_started(ctx))
    WARN(alazar_stop(ctx),"Trying to stop.");
  lock(ctx,'w'); // FIXME: There's a race condition here.  is_started() should be a condition variable
  alazar_free_config(&ctx->cfg);
  free_bufs(ctx);
  unlock(ctx);
  return SUCCESS;
Error:
  return FAILURE;
}

/** Starts the acquisition. */
int alazar_start (alazar_t ctx)
{ int i,j;
  U32 nbytes;
  lock(ctx,'w');
  nbytes=(U32)buffer_size_bytes(ctx)/(U32)active_channel_count(ctx);
  LOG("START START START\n");
  TRY(alazar_is_armed(ctx));
  // init the async read
  i=ctx->nboards;
  while(i-->0) // need to do the master board last, so iterate backwards
  {
    U32 mask = channel_mask(ctx,i);
    if(mask)
    { ERR(AlazarSetRecordSize(BOARD(i),0,ctx->cfg->nsamples)); // this effects how often trigger enable resets
      ERR(AlazarBeforeAsyncRead(BOARD(i),mask,
        0,             /* transfer offset - pre-trigger samples*/
        ctx->cfg->nsamples, /* samples per record*/
        ctx->cfg->nrecords, /* records per buffer*/
        0x7fffffff,    /* records per acquisition (0x7FFFFFFF is infinite)*/
        ADMA_NPT       /* flags - No PreTrigger - enables faster retriggering*/
        | ADMA_EXTERNAL_STARTCAPTURE /* require call to AlazarStartCapture() */
        ));
    }
  }
  // post buffers
  for(i=0;i<ctx->nboards;++i)
  { int nchan = ctx->cfg->enable[i][0]+ctx->cfg->enable[i][1];
    if(nchan>0)
      for(j=0;j<BUFS_PER_BOARD;++j)
        ERR(AlazarPostAsyncBuffer(BOARD(i),((char*)ctx->bufs[i][j]),nbytes*nchan));
  }
  ctx->ibuf=0;
  ERR(AlazarStartCapture(BOARD(0)));
  ctx->is_started=1;
  unlock(ctx);
  return SUCCESS;
Error:
  ctx->is_started=0;
  unlock(ctx);
  return FAILURE;
}

/** Stops the acquisition. */
int alazar_stop  (alazar_t ctx)
{ int i;
  lock(ctx,'w');
  LOG("STOP STOP STOP\n");
  for(i=0;i<ctx->nboards;++i) // Require Abort called for master board first
    ERR(AlazarAbortAsyncRead(BOARD(i)));
  ctx->is_started=0;
  unlock(ctx);
  return SUCCESS;
Error:
  unlock(ctx);
  return FAILURE;
}

#define CURRENT(iboard) (ctx->bufs[iboard][ctx->ibuf%BUFS_PER_BOARD])
/** Waits for the next buffer to be acquired.

 This follows the symantics of other acquisition functions for the microscope that
 hand off the input buffer, but in this case the same buffer gets returned.

 This ends up copying data from digitzer buffers to the destination buffer and then
 reposting them.  The reason they're copied is because the buffers for each board
 need to be page locked.  That is, when channels are acquired from different
 boards, the data might exist in completely different areas of memory; a copy is
 required to make the data contiguous.

 \param[in]     ctx        The device context.
 \param[in,out] buf        A pointer to an image buffer.  This may be swapped with
                           the acquired buffer.  The input buffer is added to the
                           acquisition queue.
 \param[in]     timeout_ms If the acquisition doesn't complete within the
                           specified timeout (in milliseconds), the acquisition
                           will fail.
*/
#if 0
#define FUDGE ((i>0)?92:0)
#else
#define FUDGE (0)
#endif
int alazar_fetch (alazar_t ctx, void **buf, unsigned timeout_ms)
{ unsigned i,j,j0;
  size_t o=0;
  lock(ctx,'r');
  TRY(alazar_is_started(ctx));
  { const U32 nbytes=(U32)buffer_size_bytes(ctx)/(U32)active_channel_count(ctx);
    for(i=0;i<ctx->nboards;++i)
    { int nchan = ctx->cfg->enable[i][0]+ctx->cfg->enable[i][1];
      if(nchan>0)
      { ERR(AlazarWaitAsyncBufferComplete(BOARD(i),(char*)CURRENT(i),timeout_ms));
        memcpy(((char*)buf[0])+o,((char*)CURRENT(i))+FUDGE,nbytes*nchan-FUDGE); ///< FIXME: HACK!!!  FOR SOME REASON TRIGGERING/ADDRESSING IS OFF FOR THE SECOND BOARD
        { unsigned short *p=(unsigned short*)((char*)buf[0]+o+nbytes*nchan-FUDGE);
          for(j=0;j<FUDGE/2;++j)
            p[j]=p[-1];
        }
        o+=nbytes*nchan; 
        ERR(AlazarPostAsyncBuffer(BOARD(i),(char*)CURRENT(i),nbytes*nchan));
      }
    }
  }
  ctx->ibuf++;
  unlock(ctx);
  return SUCCESS;
Error:
  unlock(ctx);
  return FAILURE;
}
#undef CURRENT

//  CONFIGURATION INTERFACE  /////////////////////////////////////////////
/** Generates a default configuration */
alazar_cfg_t alazar_make_config()
{
  alazar_cfg_t cfg;
  NEW( cfg,struct _alazar_cfg_t, 1);
  ZERO(cfg,struct _alazar_cfg_t, 1);
  cfg->sample_rate_id      = SAMPLE_RATE_125MSPS;
  { int i,j;
    for(i=0;i<MAXBOARDS;++i)
      for(j=0;j<CHANSPERBOARD;++j)
        cfg->input_range_ids[i][j] = INPUT_RANGE_PM_1_V;
  }
  cfg->aux_out_board_id=1;
  cfg->line_trig_lvl_volts = 0.5;
  cfg->ref=1;
  return cfg;
Error:
  return 0;
}

/** Releases resources held by the configuration */
void alazar_free_config(alazar_cfg_t *cfg)
{
  if(!cfg)    return;
  if(!cfg[0]) return;
  if(--(cfg[0]->ref)==0)
  { alazar_cfg_t c=cfg[0];
    cfg[0]=0;
    free(c);
  }
}

/** Setup config according to input scan parameters.

 Due to alignment requirements, the number of samples per image in a single
 channel is constrained to be divisible by some number of samples.  The
 actual number is related to the page alignment and is queried from the
 operating system.

 To make sure the image is aligned, the \a duty may be adjusted.  The input
 \a duty should be an upper bound.  It will be adjusted downwards a small
 amount (shaving a few samples off of each line).

 Divisibility by align implies there is an integer M.  Estimate one close to duty but for a smaller duty.

 \param[in]     cfg              The configuration object to modify.
 \param[in]     scans_per_second Each scan will be a row in the output image.
 \param[in]     scans            The number of rows in the output image.
 \param[in,out] duty             This is the fraction of the scan time
                                 during which samples are acquired
                                 during a scan.  Should be between 0 and 1.
*/
void alazar_set_image_size(alazar_cfg_t cfg, unsigned scans_per_second,unsigned scans,double *duty)
{ const double t = 1.0/(double)scans_per_second,
               r = samples_per_second(cfg->sample_rate_id),
               align = page_alignment_samples();
  size_t M = (size_t) (t*duty[0]*r*scans/align);                          //implicit floor
  *duty = M*align/(t*r*scans);                                            //adjust duty, aligning samples from a full frame to a page boundary
  cfg->nrecords=scans;
  cfg->nsamples=32*((U32)(t*r*duty[0]+0.5)/32);                           // round to nearest u32, and align scan to 32 sample boundary (ATS 9350 specific)

}

/** Change the line trigger level.
*/
void alazar_set_line_trigger_lvl_volts(alazar_cfg_t cfg, double volts)
{ cfg->line_trig_lvl_volts=volts;
}

/** By default no channels are enabled.  Use this to turn channels on.

 Channels are ordered like this: Board0.ChA, Board0.ChB, Board1.ChA ...
*/
void alazar_set_channel_enable(alazar_cfg_t cfg, int iboard, int ichan, int isenabled)
{ cfg->enable[iboard][ichan==CHANNEL_B]=isenabled;
}

void alazar_set_channel_input_range(alazar_cfg_t cfg, int iboard, int ichan, unsigned rangeid)
{ cfg->input_range_ids[iboard][ichan==CHANNEL_B]=rangeid;
}

void alazar_set_aux_out_board(alazar_cfg_t cfg, unsigned boardid)
{ cfg->aux_out_board_id=boardid;
}

/** Returns the image size that will be acquired by the armed device, */
void alazar_get_image_size(alazar_t ctx, unsigned *w, unsigned *h)
{ *w=*h=0;
  if(!ctx->cfg) return;
  *w=ctx->cfg->nsamples;
  *h=ctx->cfg->nrecords;
}

/** context must be armed. */
size_t alazar_get_image_size_bytes(alazar_t ctx)
{
   return buffer_size_bytes(ctx);
}
#endif // HAVE_ALAZAR